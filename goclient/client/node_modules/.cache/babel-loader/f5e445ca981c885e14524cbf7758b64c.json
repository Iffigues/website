{"ast":null,"code":"import _slicedToArray from \"/home/debian/mywebsite/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/home/debian/mywebsite/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"/home/debian/mywebsite/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _toConsumableArray from \"/home/debian/mywebsite/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/debian/mywebsite/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/debian/mywebsite/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/debian/mywebsite/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/debian/mywebsite/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/debian/mywebsite/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Bundled with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\n\n\nimport { F as Filter, A as ALLOWED_TAG_LIST, B as BANNED_TAG_LIST, a as ATTRIBUTES, b as FILTER_DENY, c as ATTRIBUTES_TO_PROPS, T as TAGS, E as Element, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, f as FILTER_NO_CAST } from './bundle-94421b73.js';\nexport { A as ALLOWED_TAG_LIST, a as ATTRIBUTES, c as ATTRIBUTES_TO_PROPS, B as BANNED_TAG_LIST, E as Element, n as FILTER_ALLOW, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, b as FILTER_DENY, f as FILTER_NO_CAST, F as Filter, M as Matcher, T as TAGS, k as TYPE_EMBEDDED, g as TYPE_FLOW, i as TYPE_HEADING, l as TYPE_INTERACTIVE, m as TYPE_PALPABLE, j as TYPE_PHRASING, h as TYPE_SECTION, o as match } from './bundle-94421b73.js';\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nvar INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nvar StyleFilter = /*#__PURE__*/function (_Filter) {\n  _inherits(StyleFilter, _Filter);\n\n  function StyleFilter() {\n    _classCallCheck(this, StyleFilter);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StyleFilter).apply(this, arguments));\n  }\n\n  _createClass(StyleFilter, [{\n    key: \"attribute\",\n    value: function attribute(name, value) {\n      if (name === 'style') {\n        Object.keys(value).forEach(function (key) {\n          if (String(value[key]).match(INVALID_STYLES)) {\n            // eslint-disable-next-line no-param-reassign\n            delete value[key];\n          }\n        });\n      } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n      return value;\n    }\n  }]);\n\n  return StyleFilter;\n}(Filter);\n/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\n\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nvar ALLOWED_ATTRS = /^(aria\\x2D|data\\x2D|[0-9A-Z_a-z\\u017F\\u212A]+:)/i;\nvar OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(markup) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var matchers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var filters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    _classCallCheck(this, Parser);\n\n    var _props$allowList;\n\n    _defineProperty(this, \"allowed\", void 0);\n\n    _defineProperty(this, \"banned\", void 0);\n\n    _defineProperty(this, \"blocked\", void 0);\n\n    _defineProperty(this, \"container\", void 0);\n\n    _defineProperty(this, \"content\", []);\n\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"matchers\", void 0);\n\n    _defineProperty(this, \"filters\", void 0);\n\n    _defineProperty(this, \"keyIndex\", void 0);\n\n    if (process.env.NODE_ENV !== \"production\" && markup && typeof markup !== 'string') {\n      throw new TypeError('Interweave parser requires a valid string.');\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [].concat(_toConsumableArray(filters), [new StyleFilter()]);\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set((_props$allowList = props.allowList) !== null && _props$allowList !== void 0 ? _props$allowList : ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n\n\n  _createClass(Parser, [{\n    key: \"applyAttributeFilters\",\n    value: function applyAttributeFilters(name, value) {\n      return this.filters.reduce(function (nextValue, filter) {\n        return nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue;\n      }, value);\n    }\n    /**\n     * Loop through and apply all registered node filters.\n     */\n\n  }, {\n    key: \"applyNodeFilters\",\n    value: function applyNodeFilters(name, node) {\n      // Allow null to be returned\n      return this.filters.reduce(function (nextNode, filter) {\n        return nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode;\n      }, node);\n    }\n    /**\n     * Loop through and apply all registered matchers to the string.\n     * If a match is found, create a React element, and build a new array.\n     * This array allows React to interpolate and render accordingly.\n     */\n\n  }, {\n    key: \"applyMatchers\",\n    value: function applyMatchers(string, parentConfig) {\n      var _this = this;\n\n      var elements = {};\n      var props = this.props;\n      var matchedString = string;\n      var elementIndex = 0;\n      var parts = null;\n      this.matchers.forEach(function (matcher) {\n        var tagName = matcher.asTag().toLowerCase();\n\n        var config = _this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n\n        if (props[matcher.inverseName] || !_this.isTagAllowed(tagName)) {\n          return;\n        } // Skip matchers in which the child cannot be rendered\n\n\n        if (!_this.canRenderChild(parentConfig, config)) {\n          return;\n        } // Continuously trigger the matcher until no matches are found\n\n\n        var tokenizedString = '';\n\n        while (matchedString && (parts = matcher.match(matchedString))) {\n          var _parts = parts,\n              index = _parts.index,\n              length = _parts.length,\n              match = _parts.match,\n              valid = _parts.valid,\n              isVoid = _parts.void,\n              partProps = _objectWithoutProperties(_parts, [\"index\", \"length\", \"match\", \"valid\", \"void\"]);\n\n          var tokenName = matcher.propName + String(elementIndex); // Piece together a new string with interpolated tokens\n\n          if (index > 0) {\n            tokenizedString += matchedString.slice(0, index);\n          }\n\n          if (valid) {\n            tokenizedString += isVoid ? \"{{{\".concat(tokenName, \"/}}}\") : \"{{{\".concat(tokenName, \"}}}\").concat(match, \"{{{/\").concat(tokenName, \"}}}\");\n            _this.keyIndex += 1;\n            elementIndex += 1;\n            elements[tokenName] = {\n              children: match,\n              matcher: matcher,\n              props: _objectSpread({}, props, partProps, {\n                key: _this.keyIndex\n              })\n            };\n          } else {\n            tokenizedString += match;\n          } // Reduce the string being matched against,\n          // otherwise we end up in an infinite loop!\n\n\n          if (matcher.greedy) {\n            matchedString = tokenizedString + matchedString.slice(index + length);\n            tokenizedString = '';\n          } else {\n            // eslint-disable-next-line unicorn/explicit-length-check\n            matchedString = matchedString.slice(index + (length || match.length));\n          }\n        } // Update the matched string with the tokenized string,\n        // so that the next matcher can apply to it.\n\n\n        if (!matcher.greedy) {\n          matchedString = tokenizedString + matchedString;\n        }\n      });\n\n      if (elementIndex === 0) {\n        return string;\n      }\n\n      return this.replaceTokens(matchedString, elements);\n    }\n    /**\n     * Determine whether the child can be rendered within the parent.\n     */\n\n  }, {\n    key: \"canRenderChild\",\n    value: function canRenderChild(parentConfig, childConfig) {\n      if (!parentConfig.tagName || !childConfig.tagName) {\n        return false;\n      } // No children\n\n\n      if (parentConfig.void) {\n        return false;\n      } // Valid children\n\n\n      if (parentConfig.children.length > 0) {\n        return parentConfig.children.includes(childConfig.tagName);\n      }\n\n      if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n        return false;\n      } // Valid parent\n\n\n      if (childConfig.parent.length > 0) {\n        return childConfig.parent.includes(parentConfig.tagName);\n      } // Self nesting\n\n\n      if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n        return false;\n      } // Content category type\n\n\n      return Boolean(parentConfig && parentConfig.content & childConfig.type);\n    }\n    /**\n     * Convert line breaks in a string to HTML `<br/>` tags.\n     * If the string contains HTML, we should not convert anything,\n     * as line breaks should be handled by `<br/>`s in the markup itself.\n     */\n\n  }, {\n    key: \"convertLineBreaks\",\n    value: function convertLineBreaks(markup) {\n      var _this$props = this.props,\n          noHtml = _this$props.noHtml,\n          disableLineBreaks = _this$props.disableLineBreaks;\n\n      if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n        return markup;\n      } // Replace carriage returns\n\n\n      var nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n      nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n      nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n      return nextMarkup;\n    }\n    /**\n     * Create a detached HTML document that allows for easy HTML\n     * parsing while not triggering scripts or loading external\n     * resources.\n     */\n\n  }, {\n    key: \"createContainer\",\n    value: function createContainer(markup) {\n      var _this$props$container;\n\n      var factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;\n      var doc = factory();\n\n      if (!doc) {\n        return undefined;\n      }\n\n      var tag = (_this$props$container = this.props.containerTagName) !== null && _this$props$container !== void 0 ? _this$props$container : 'body';\n      var el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n      if (markup.match(INVALID_ROOTS)) {\n        if (process.env.NODE_ENV !== \"production\") {\n          throw new Error('HTML documents as Interweave content are not supported.');\n        }\n      } else {\n        el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n      }\n\n      return el;\n    }\n    /**\n     * Convert an elements attribute map to an object map.\n     * Returns null if no attributes are defined.\n     */\n\n  }, {\n    key: \"extractAttributes\",\n    value: function extractAttributes(node) {\n      var _this2 = this;\n\n      var allowAttributes = this.props.allowAttributes;\n      var attributes = {};\n      var count = 0;\n\n      if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n        return null;\n      } // @ts-expect-error Cant type iterator\n\n\n      _toConsumableArray(node.attributes).forEach(function (attr) {\n        var name = attr.name,\n            value = attr.value;\n        var newName = name.toLowerCase();\n        var filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n        if (!_this2.isSafe(node)) {\n          return;\n        } // Do not allow denied attributes, excluding ARIA attributes\n        // Do not allow events or XSS injections\n\n\n        if (!newName.match(ALLOWED_ATTRS) && (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))) {\n          return;\n        } // Apply attribute filters\n\n\n        var newValue = newName === 'style' ? _this2.extractStyleAttribute(node) : value; // Cast to boolean\n\n        if (filter === FILTER_CAST_BOOL) {\n          newValue = true; // Cast to number\n        } else if (filter === FILTER_CAST_NUMBER) {\n          newValue = Number.parseFloat(String(newValue)); // Cast to string\n        } else if (filter !== FILTER_NO_CAST) {\n          newValue = String(newValue);\n        }\n\n        attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = _this2.applyAttributeFilters(newName, newValue);\n        count += 1;\n      });\n\n      if (count === 0) {\n        return null;\n      }\n\n      return attributes;\n    }\n    /**\n     * Extract the style attribute as an object and remove values that allow for attack vectors.\n     */\n\n  }, {\n    key: \"extractStyleAttribute\",\n    value: function extractStyleAttribute(node) {\n      var styles = {}; // eslint-disable-next-line unicorn/prefer-spread\n\n      Array.from(node.style).forEach(function (key) {\n        var value = node.style[key];\n\n        if (typeof value === 'string' || typeof value === 'number') {\n          styles[key.replace(/-([a-z])/g, function (match, letter) {\n            return String(letter).toUpperCase();\n          })] = value;\n        }\n      });\n      return styles;\n    }\n    /**\n     * Return configuration for a specific tag.\n     */\n\n  }, {\n    key: \"getTagConfig\",\n    value: function getTagConfig(tagName) {\n      var common = {\n        children: [],\n        content: 0,\n        invalid: [],\n        parent: [],\n        self: true,\n        tagName: '',\n        type: 0,\n        void: false\n      }; // Only spread when a tag config exists,\n      // otherwise we use the empty `tagName`\n      // for parent config inheritance.\n\n      if (TAGS[tagName]) {\n        return _objectSpread({}, common, TAGS[tagName], {\n          tagName: tagName\n        });\n      }\n\n      return common;\n    }\n    /**\n     * Verify that a node is safe from XSS and injection attacks.\n     */\n\n  }, {\n    key: \"isSafe\",\n    value: function isSafe(node) {\n      // URLs should only support HTTP, email and phone numbers\n      if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n        var href = node.getAttribute('href'); // Fragment protocols start with about:\n        // So let's just allow them\n\n        if (href !== null && href !== void 0 && href.startsWith('#')) {\n          return true;\n        }\n\n        var protocol = node.protocol.toLowerCase();\n        return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n      }\n\n      return true;\n    }\n    /**\n     * Verify that an HTML tag is allowed to render.\n     */\n\n  }, {\n    key: \"isTagAllowed\",\n    value: function isTagAllowed(tagName) {\n      if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n        return false;\n      } // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\n\n      return this.props.allowElements || this.allowed.has(tagName);\n    }\n    /**\n     * Parse the markup by injecting it into a detached document,\n     * while looping over all child nodes and generating an\n     * array to interpolate into JSX.\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      if (!this.container) {\n        return [];\n      }\n\n      return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n    }\n    /**\n     * Loop over the nodes children and generate a\n     * list of text nodes and React elements.\n     */\n\n  }, {\n    key: \"parseNode\",\n    value: function parseNode(parentNode, parentConfig) {\n      var _this3 = this;\n\n      var _this$props2 = this.props,\n          noHtml = _this$props2.noHtml,\n          noHtmlExceptMatchers = _this$props2.noHtmlExceptMatchers,\n          allowElements = _this$props2.allowElements,\n          transform = _this$props2.transform,\n          transformOnlyAllowList = _this$props2.transformOnlyAllowList;\n      var content = [];\n      var mergedText = ''; // @ts-expect-error Cant type iterator\n\n      _toConsumableArray(parentNode.childNodes).forEach(function (node) {\n        // Create React elements from HTML elements\n        if (node.nodeType === ELEMENT_NODE) {\n          var tagName = node.nodeName.toLowerCase();\n\n          var config = _this3.getTagConfig(tagName); // Persist any previous text\n\n\n          if (mergedText) {\n            content.push(mergedText);\n            mergedText = '';\n          } // Apply node filters first\n\n\n          var nextNode = _this3.applyNodeFilters(tagName, node);\n\n          if (!nextNode) {\n            return;\n          } // Apply transformation second\n\n\n          var children;\n\n          if (transform && !(transformOnlyAllowList && !_this3.isTagAllowed(tagName))) {\n            _this3.keyIndex += 1;\n            var key = _this3.keyIndex; // Must occur after key is set\n\n            children = _this3.parseNode(nextNode, config);\n            var transformed = transform(nextNode, children, config);\n\n            if (transformed === null) {\n              return;\n            }\n\n            if (typeof transformed !== 'undefined') {\n              content.push( /*#__PURE__*/React.cloneElement(transformed, {\n                key: key\n              }));\n              return;\n            } // Reset as we're not using the transformation\n\n\n            _this3.keyIndex = key - 1;\n          } // Never allow these tags (except via a transformer)\n\n\n          if (_this3.banned.has(tagName)) {\n            return;\n          } // Only render when the following criteria is met:\n          //  - HTML has not been disabled\n          //  - Tag is allowed\n          //  - Child is valid within the parent\n\n\n          if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && _this3.isTagAllowed(tagName) && (allowElements || _this3.canRenderChild(parentConfig, config))) {\n            var _children;\n\n            _this3.keyIndex += 1; // Build the props as it makes it easier to test\n\n            var attributes = _this3.extractAttributes(nextNode);\n\n            var elementProps = {\n              tagName: tagName\n            };\n\n            if (attributes) {\n              elementProps.attributes = attributes;\n            }\n\n            if (config.void) {\n              elementProps.selfClose = config.void;\n            }\n\n            content.push( /*#__PURE__*/React.createElement(Element, _objectSpread({}, elementProps, {\n              key: _this3.keyIndex\n            }), (_children = children) !== null && _children !== void 0 ? _children : _this3.parseNode(nextNode, config))); // Render the children of the current element only.\n            // Important: If the current element is not allowed,\n            // use the parent element for the next scope.\n          } else {\n            content = [].concat(_toConsumableArray(content), _toConsumableArray(_this3.parseNode(nextNode, config.tagName ? config : parentConfig)));\n          } // Apply matchers if a text node\n\n        } else if (node.nodeType === TEXT_NODE) {\n          var text = noHtml && !noHtmlExceptMatchers ? node.textContent : // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n          _this3.applyMatchers(node.textContent || '', parentConfig);\n\n          if (Array.isArray(text)) {\n            content = [].concat(_toConsumableArray(content), _toConsumableArray(text));\n          } else {\n            mergedText += text;\n          }\n        }\n      });\n\n      if (mergedText) {\n        content.push(mergedText);\n      }\n\n      return content;\n    }\n    /**\n     * Deconstruct the string into an array, by replacing custom tokens with React elements,\n     * so that React can render it correctly.\n     */\n\n  }, {\n    key: \"replaceTokens\",\n    value: function replaceTokens(tokenizedString, elements) {\n      if (!tokenizedString.includes('{{{')) {\n        return tokenizedString;\n      }\n\n      var nodes = [];\n      var text = tokenizedString;\n      var open = null; // Find an open token tag\n\n      while (open = text.match(OPEN_TOKEN)) {\n        var _open = open,\n            _open2 = _slicedToArray(_open, 2),\n            match = _open2[0],\n            tokenName = _open2[1];\n\n        var startIndex = open.index;\n        var isVoid = match.includes('/');\n\n        if (process.env.NODE_ENV !== \"production\" && !elements[tokenName]) {\n          throw new Error(\"Token \\\"\".concat(tokenName, \"\\\" found but no matching element to replace with.\"));\n        } // Extract the previous non-token text\n\n\n        if (startIndex > 0) {\n          nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n          text = text.slice(startIndex);\n        }\n\n        var _elements$tokenName = elements[tokenName],\n            children = _elements$tokenName.children,\n            matcher = _elements$tokenName.matcher,\n            elementProps = _elements$tokenName.props;\n        var endIndex = void 0; // Use tag as-is if void\n\n        if (isVoid) {\n          endIndex = match.length;\n          nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n        } else {\n          var close = text.match(new RegExp(\"{{{/\".concat(tokenName, \"}}}\")));\n\n          if (process.env.NODE_ENV !== \"production\" && !close) {\n            throw new Error(\"Closing token missing for interpolated element \\\"\".concat(tokenName, \"\\\".\"));\n          }\n\n          endIndex = close.index + close[0].length;\n          nodes.push(matcher.createElement(this.replaceTokens(text.slice(match.length, close.index), elements), elementProps));\n        } // Reduce text for the next interation\n\n\n        text = text.slice(endIndex);\n      } // Extra the remaining text\n\n\n      if (text.length > 0) {\n        nodes.push(text);\n      } // Reduce to a string if possible\n\n\n      if (nodes.length === 0) {\n        return '';\n      }\n\n      if (nodes.length === 1 && typeof nodes[0] === 'string') {\n        return nodes[0];\n      }\n\n      return nodes;\n    }\n  }]);\n\n  return Parser;\n}();\n/* eslint-disable react/jsx-fragments */\n\n\nfunction Markup(props) {\n  var _ref;\n\n  var attributes = props.attributes,\n      className = props.className,\n      containerTagName = props.containerTagName,\n      content = props.content,\n      emptyContent = props.emptyContent,\n      parsedContent = props.parsedContent,\n      tagName = props.tagName,\n      baseNoWrap = props.noWrap;\n  var tag = (_ref = containerTagName !== null && containerTagName !== void 0 ? containerTagName : tagName) !== null && _ref !== void 0 ? _ref : 'span';\n  var noWrap = tag === 'fragment' ? true : baseNoWrap;\n  var mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    var markup = new Parser(content !== null && content !== void 0 ? content : '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    className: className,\n    tagName: tag\n  }, mainContent);\n}\n/* eslint-disable promise/prefer-await-to-callbacks */\n\n\nfunction Interweave(props) {\n  var attributes = props.attributes,\n      className = props.className,\n      _props$content = props.content,\n      content = _props$content === void 0 ? '' : _props$content,\n      _props$disableFilters = props.disableFilters,\n      disableFilters = _props$disableFilters === void 0 ? false : _props$disableFilters,\n      _props$disableMatcher = props.disableMatchers,\n      disableMatchers = _props$disableMatcher === void 0 ? false : _props$disableMatcher,\n      _props$emptyContent = props.emptyContent,\n      emptyContent = _props$emptyContent === void 0 ? null : _props$emptyContent,\n      _props$filters = props.filters,\n      filters = _props$filters === void 0 ? [] : _props$filters,\n      _props$matchers = props.matchers,\n      matchers = _props$matchers === void 0 ? [] : _props$matchers,\n      _props$onAfterParse = props.onAfterParse,\n      onAfterParse = _props$onAfterParse === void 0 ? null : _props$onAfterParse,\n      _props$onBeforeParse = props.onBeforeParse,\n      onBeforeParse = _props$onBeforeParse === void 0 ? null : _props$onBeforeParse,\n      _props$tagName = props.tagName,\n      tagName = _props$tagName === void 0 ? 'span' : _props$tagName,\n      _props$noWrap = props.noWrap,\n      noWrap = _props$noWrap === void 0 ? false : _props$noWrap,\n      parserProps = _objectWithoutProperties(props, [\"attributes\", \"className\", \"content\", \"disableFilters\", \"disableMatchers\", \"emptyContent\", \"filters\", \"matchers\", \"onAfterParse\", \"onBeforeParse\", \"tagName\", \"noWrap\"]);\n\n  var allMatchers = disableMatchers ? [] : matchers;\n  var allFilters = disableFilters ? [] : filters;\n  var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  var afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(function (matcher) {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  var markup = beforeCallbacks.reduce(function (string, callback) {\n    var nextString = callback(string, props);\n\n    if (process.env.NODE_ENV !== \"production\" && typeof nextString !== 'string') {\n      throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n    }\n\n    return nextString;\n  }, content !== null && content !== void 0 ? content : ''); // Parse the markup\n\n  var parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  var nodes = afterCallbacks.reduce(function (parserNodes, callback) {\n    var nextNodes = callback(parserNodes, props);\n\n    if (process.env.NODE_ENV !== \"production\" && !Array.isArray(nextNodes)) {\n      throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n    }\n\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    className: className // eslint-disable-next-line react/destructuring-assignment\n    ,\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes,\n    tagName: tagName\n  });\n}\n\nexport { Interweave, Markup, Parser };","map":null,"metadata":{},"sourceType":"module"}